* Factor out context nesting from IR
  * Interpreter is dynamic enough to be singular and global
  * A context in this case is effectively a set of the same variable names, but prefixed
    * ex. distance prefixes to left_distance, right_distance, out_distance
  * Should open the door to relatively trivial rust / naga backends

  SKIPPED: Struct params + functions are necessary, so refactoring with proper support is preferable

* Further generalization for Elysian
  * Since all composition is done via function, structure doesn't need to be ergonomic
    * Data ergonomics can be achieved via custom haskell-like textual format
  * Should ultimately end up with Primitive (or Field), Modifier, Combine and Alias variants
    * Each of these should hold a sub-enum to start with
      * Eventual goal being generalization to traits, allow extension through conversion to IR

  DONE: Elysian now nests Field and Modifier enums

* Reinstate IntoBlock usage
  * Implement for Field, Modifier, Combinator
  * Move relevant parts of Elysian IntoStmt
  
  SKIPPED: Opted to factor out non-API trait usage until needed

* Implement function support
  * Corresponding IntoFunction trait to populate Module
  * Walk structure to discover needed functions
  * Walk again to assemble call chain

  DONE: Functions are now representable

* Implement robust struct support
  * Replace arbitrary Stmt variants with proper field addressing

  DONE: All reads and writes are now done via path

* Formalize backend / frontend
  * Existing backend naming is backwards, since it all governs output
  * Rename existing backends to frontends
  * Actual backends would be things that produce Elysian structure:
    * Existing function-based Elysian / IR composition APIs
    * Textual representation for serialization / proc macro parsing
    * Graph-based editor

  DONE: Corrected naming

* Make Into* traits object-safe so they can be used as dyn inside Elysian
  * This should ultimately subsume the Alias system,
    allowing Circle, Ring, etc to retain their structure in IR,
    and thus in generated code (ex. Ring calling out to Circle calling out to Point, etc)
  * Also allows extension through arbitrary types,
    with lifting traits replacing the existing field() / modifier() methods
    * Would likely be more scalable to represent each one as its own type
  
  PARTIAL: Functionality has been de-traited for now, but has been refactored to pass by reference

* Generalize Property
  * Currently inextensible, need something like a string name
  * However, name collision is a concern for strings
  * Need some sort of trait-based approach w/type-uuid to guarantee uniqueness
    * Required-impl function to return name
    * Default-impl function to return name w/UUID-derived suffix

  DONE: Implemented via Identifier

* Fix function variant generation
  * Infinite vs non-infinite Elongate
  * Property-specific smooth blend functions
    * Currently preventing smooth distance / gradient from coexisting

  DONE: Identifiers now store names as Cow<'static, str>,
        concatenate by adding UUIDs together deterministically.
        Elongate / Smooth* have been refactored to generate
        distinct function specializations based on their member values

* Use Identifier UUIDs to ensure no name collision in generated code
  
  DONE: Zero-trimmed UUIDs are now used as suffixes to differentiate same-named identifiers

* Generalize AST -> IR conversion
  * Elysian variants should ultimately contain Box<dyn Trait>,
    where Trait converts into the relevant IR
  * Shouldn't need Alias when that is in place,
    * Preserves more information that can be represented in output
      * ex. Ring's function composing Circle's function, etc
    * Alias types can defer to their component parts' IR conversion functions
  
  DONE: Field, PreModifier and PostModifier have been replace with the AsIR trait
        and corresponding dyn machinery

* Generalize combinators via AsIR

  DONE: Combiner enums have been factored into AsIR implementors

* Generate dedicated functions for alias types instead of inlining directly
  * Clearer intent, better code sharing
  * Allows rolling back Vec<Expr<N, V>> change

  DONE: Aliases are now simply AsIR implementors that depend on other AsIR implementors
        Rolled back Vec change, and also moved hash_ir / clone_ir to blanket-impled traits for ergonomics

* Replace N, V parameters with a single T describing a type specification
  * Trait with one associated type per relevant AST type
  * i.e. Prim32 would specify f32 and [f32; N] types
         Prim64 would specify f64 and [f64; N] types
         Glam32 would specify f32 and Vec* types,
         Glam64 would specify f64 and DVec* types,
         etc.

  DONE: Implemented via TypeSpec trait, extended rust-gpu-bridge with f64 support

* Formalize vector arity
  * Certain properties (ex. color) need a fixed arity,
    whereas others vary depending on the vector space
  * Can probably host a 'vector space' assoc type alongside
    vector arity types, use for position, gradient, etc.

  DONE: Implemented as VectorSpace trait and variant type,
        added const params to drive it

* Avoid specifying dimensionality before IR
  * Should be able to remove it from Elysian,
    supply constant at evaluation time

  SKIPPED: Can't be done without removing N param from everything,
           since it's necessary for everything that composes Value,
           and everything that needs to name such types

* Refactor module entry points as regular functions
  * Emit a call hierarchy for compositional AsModule types instead of inlining everything

  DONE: Entry points are now regular functions specified by identifier,
        and can call one another instead of having to inline

* Abstraction of modifier application
  * Should be viable now AsModule types' generated code is compositional
  * Can refactor Field to take a single AsIR,
    lift it into an ApplyModifiers struct as dyn AsModule,
    and emit appropriate pre / post IR
  * Currently built into field, but should be a wrapper around DynAsModule
    * i.e. Should work with combine
      * Semantically just prefixing and suffixing, so should be doable
  * Intersects with the "do something with field" domain needed for 3D

  DONE: Field now wraps a single AsIR, Modify wraps field AsModule and pre / post AsIR modifiers

=========================================================================================================

* 3D support
  * How to represent morphisms between vector spaces?
    * Doesn't fit comfortably into the existing pre / post modifier idiom
    * Seems like a more general wrapper

* Stronger typing for pre / post / field IR conversion
  * At minimum, create separate traits to identify a given symbol as each
    * May be better for Modifier to be a single trait with pre / post methods
      * Makes it more ergonomic to support pre + post ops like scale
  * Since the base AST has a Value representation,
    may be able to reinstate something resembling move semantics?

* Domain evaluation
  i.e. Being able to evaluate a subset of a given field's computations
       * ex. Just distance, just gradient, distance + uv, etc.
       * Useful for blending optimizations:
         * Evaluate distance
         * Pick a context
         * Evaluate rest of domains

* Error handling pass
  * Replace panics with Result and error types

* Long-term: Consider using a subset of rhai for IR / interpreter purposes
  * Large in scope, but offers simplification via disabling functionality
    * Raw engine + minimal set of modules
  * Would simplify rust -> IR -> output process
  * Opens up a lot of potential for extensibility

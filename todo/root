* Factor out context nesting from IR
  * Interpreter is dynamic enough to be singular and global
  * A context in this case is effectively a set of the same variable names, but prefixed
    * ex. distance prefixes to left_distance, right_distance, out_distance
  * Should open the door to relatively trivial rust / naga backends

  SKIPPED: Struct params + functions are necessary, so refactoring with proper support is preferable

* Further generalization for Elysian
  * Since all composition is done via function, structure doesn't need to be ergonomic
    * Data ergonomics can be achieved via custom haskell-like textual format
  * Should ultimately end up with Primitive (or Field), Modifier, Combine and Alias variants
    * Each of these should hold a sub-enum to start with
      * Eventual goal being generalization to traits, allow extension through conversion to IR

  DONE: Elysian now nests Field and Modifier enums

* Reinstate IntoBlock usage
  * Implement for Field, Modifier, Combinator
  * Move relevant parts of Elysian IntoStmt
  
  SKIPPED: Opted to factor out non-API trait usage until needed

* Implement function support
  * Corresponding IntoFunction trait to populate Module
  * Walk structure to discover needed functions
  * Walk again to assemble call chain

  DONE: Functions are now representable

* Implement robust struct support
  * Replace arbitrary Stmt variants with proper field addressing

  DONE: All reads and writes are now done via path

* Formalize backend / frontend
  * Existing backend naming is backwards, since it all governs output
  * Rename existing backends to frontends
  * Actual backends would be things that produce Elysian structure:
    * Existing function-based Elysian / IR composition APIs
    * Textual representation for serialization / proc macro parsing
    * Graph-based editor

  DONE: Corrected naming

* Make Into* traits object-safe so they can be used as dyn inside Elysian
  * This should ultimately subsume the Alias system,
    allowing Circle, Ring, etc to retain their structure in IR,
    and thus in generated code (ex. Ring calling out to Circle calling out to Point, etc)
  * Also allows extension through arbitrary types,
    with lifting traits replacing the existing field() / modifier() methods
    * Would likely be more scalable to represent each one as its own type
  
  PARTIAL: Functionality has been de-traited for now, but has been refactored to pass by reference

=========================================================================================================

* Generalize Property
  * Currently inextensible, need something like a string name
  * However, name collision is a concern for strings
  * Need some sort of trait-based approach w/type-uuid to guarantee uniqueness
    * Required-impl function to return name
    * Default-impl function to return name w/UUID-derived suffix

* Fix function variant generation
  * Infinite vs non-infinite Elongate
  * Property-specific smooth blend functions

* Generalize AST -> IR conversion
  * Elysian variants should ultimately contain Box<dyn Trait>,
    where Trait converts into the relevant IR
  * Shouldn't need Alias when that is in place,
    * Preserves more information that can be represented in output
      * ex. Ring's function composing Circle's function, etc
    * Alias types can defer to their component parts' IR conversion functions

* Error handling pass
  * Replace panics with Result and error types
